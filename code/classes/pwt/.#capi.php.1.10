<?php
/**
	Този клас ще реализира апи-то
*/
class capi{
	var $m_xml;
	var $m_errCnt;
	var $m_errMsg;
	var $m_resultArray;
	var $m_getData;
	var $m_action;
	var $m_templateObjectDetails;
	var $m_templateId;
	var $m_con;
	var $m_documentId;
	var $m_uid;
	var $m_submittingAuthorUid;
	var $m_username;
	var $m_password;
	var $m_journalId;
	var $m_previousSessionUser;
	var $m_previuosUser;
	function __construct($pFieldTempl){
		$this->m_xml = $pFieldTempl['xml'];
		$this->m_username = $pFieldTempl['username'];
		$this->m_password = $pFieldTempl['password'];
		$this->m_errCnt = 0;
		$this->m_errMsg = '';
		$this->m_resultArray = array();
		$this->m_getData = true;
		$this->m_action = $pFieldTempl['action'];
		$this->m_templateObjectDetails = array();
		$this->m_con = new DBCn();
		$this->m_con->Open();
		$this->m_previousSessionUser = $_SESSION['suser'];

		global $user;
		$this->m_previuosUser = $user;
	}

	function Authenticate(){
// 		$lSql = 'SELECT * FROM sitelogin(\'' . q($this->m_username)  . '\', \'' . q($this->m_password) . '\', \'' . q($_SERVER['REMOTE_ADDR']) . '\')';
// 		$this->ExecuteSqlStatement($lSql);
// 		$this->m_uid = (int)$this->m_con->mRs['id'];
		global $user;
		$user = new clogin($this->m_username, $this->m_password, $_SERVER['REMOTE_ADDR']);
// 		$_SESSION['suser'] = serialize($user);
		if ($user->state != 1) {
			$this->SetError(getstr('pwt.api.noSuchUser'));
		}
		$this->m_uid = $user->id;
		if(!$this->m_uid){
			$this->SetError(getstr('pwt.api.noSuchUser'));
		}

	}

	function ProcessDocumentSubmit(){
		$this->BaseValidateXml();
		$this->ImportDocument();
	}

	/**
	 * Тук ще импортираме получения xml в базата
	 */
	function ImportDocument(){

		//Правим всичко в 1 транзакция - ако стане проблем ще rollback-нем
		$this->ExecuteSqlStatement('BEGIN TRANSACTION;');

// 		$this->SetError(getstr('pwt.api.xmlIsValid'));

		$lXmlDom = new DOMDocument('1.0', 'UTF-8');
		if(!$lXmlDom->loadXML($this->m_xml)){
			$this->SetError(getstr('pwt.api.xmlIsInvalid'));
		}
		$lXPath = new DOMXPath($lXmlDom);

		//Слагаме имената на възлите като техни атрибути понеже xml парсинга на Postgresql е непълен и не може автоматично да се вземе името на текущия възел
		//Слагаме и индексите понеже в postres-а няма релативни възли в xpath-а и не можем да го сметнем
		$lObjectsQuery = '/document/objects//*[count(ancestor-or-self::fields) = 0]';
		$lObjects = $lXPath->query($lObjectsQuery);
		for($i = 0; $i < $lObjects->length; ++$i){
			$lCurrentObject = $lObjects->item($i);
			$lCurrentObject->setAttribute('is_object', 1);
			$lPreviousObjectsOfTheSameType = $lXPath->evaluate('count(./preceding-sibling::' . $lCurrentObject->nodeName . ')', $lCurrentObject);
			$lCurrentObject->setAttribute('object_idx', $lPreviousObjectsOfTheSameType + 1);
			$lCurrentObject->setAttribute('node_name', $lCurrentObject->nodeName);
		}

		$lFieldsQuery = '/document/objects//fields/*';
		$lFields = $lXPath->query($lFieldsQuery);
		for($i = 0; $i < $lFields->length; ++$i){
			$lCurrentField = $lFields->item($i);
			$lCurrentField->setAttribute('is_field', 1);
			$lCurrentField->setAttribute('node_name', $lCurrentField->nodeName);
		}


// 		var_dump($lXPath->query('/document/objects//author[fields/submitting_author[value="1"]]')->length);
		$lAuthors = $lXPath->query('/document/objects//author');
		$lSubmittingAuthor = null;
		for($i = 0; $i < $lAuthors->length; ++$i){
			$lSubmittingAuthorValNode = $lXPath->query('./fields/submitting_author/value', $lAuthors->item($i));
			if($lSubmittingAuthorValNode->length && (int)$lSubmittingAuthorValNode->item(0)->nodeValue == 1){
				$lSubmittingAuthor = $lAuthors->item($i);
				break;
			}
		}

		if(!$lSubmittingAuthor){
			$this->SetError(getstr('pwt.api.xmlIsInvalid') . getstr('pwt.api.noSubmittingAuthor'));
		}
		$lSubmittingAuthorData = array();
		$lSubmittingAuthorFields = array(
			'email' => './fields/e-mail/value',
			'salutation' => './fields/salutation/value',
			'first_name' => './fields/first_name/value',
			'middle_name' => './fields/middle_name/value',
			'last_name' => './fields/last_name/value',
			'aff' => './fields/secondary_address[1]/fields/affiliation/value',
			'city' => './fields/secondary_address[1]/fields/city/value',
			'country' => './fields/secondary_address[1]/fields/country/value',
		);
		foreach ($lSubmittingAuthorFields as $lFieldName => $lXPathQuery) {
			$lNodes = $lXPath->query($lXPathQuery, $lSubmittingAuthor);
// 			var_dump($lNodes, $lXPathQuery);
			if($lNodes->length){
				$lSubmittingAuthorData[$lFieldName] = trim($lNodes->item(0)->nodeValue);
			}
		}
// 		var_dump($lSubmittingAuthorData);
		if(!$lSubmittingAuthorData['email']){
			$this->SetError(getstr('pwt.api.xmlIsInvalid') . getstr('pwt.api.submittingAuthorDoesNotHaveEmail'));
		}

		exit;
// 		var_dump('SELECT * FROM pwt.spCreateUsrForAuthorApi(
// 			\'' . q($lSubmittingAuthorData['email']) . '\',
// 			\'' . q($lSubmittingAuthorData['salutation']) . '\',
// 			\'' . q($lSubmittingAuthorData['first_name']) . '\',
// 			\'' . q($lSubmittingAuthorData['middle_name']) . '\',
// 			\'' . q($lSubmittingAuthorData['last_name']) . '\',
// 			\'' . q($lSubmittingAuthorData['aff']) . '\',
// 			\'' . q($lSubmittingAuthorData['city']) . '\',
// 			\'' . q($lSubmittingAuthorData['country']) . '\'
// 		)');
		$this->ExecuteSqlStatement('SELECT * FROM pwt.spCreateUsrForAuthorApi(
			\'' . q($lSubmittingAuthorData['email']) . '\',
			\'' . q($lSubmittingAuthorData['salutation']) . '\',
			\'' . q($lSubmittingAuthorData['first_name']) . '\',
			\'' . q($lSubmittingAuthorData['middle_name']) . '\',
			\'' . q($lSubmittingAuthorData['last_name']) . '\',
			\'' . q($lSubmittingAuthorData['aff']) . '\',
			\'' . q($lSubmittingAuthorData['city']) . '\',
			\'' . q($lSubmittingAuthorData['country']) . '\'
		)');

		$this->m_submittingAuthorUid = (int)$this->m_con->mRs['uid'];

		if(!$this->m_submittingAuthorUid){
			$this->SetError(getstr('pwt.api.couldNotCreateUserForSubmittingAuthor'));
		}
// 		var_dump($this->m_con->mRs['user_exists']);
		if(!(int)$this->m_con->mRs['user_exists']){
			sendMailToAuthorApiRegister($this->m_con->mRs['email'], $this->m_con->mRs['upass'], $this->m_con->mRs['fullname']);
		}




		for($i = 0; $i < $lFields->length; ++$i){
			$lCurrentField = $lFields->item($i);
			$lCurrentField->setAttribute('is_field', 1);
			$lCurrentField->setAttribute('node_name', $lCurrentField->nodeName);
		}


		$this->ExecuteSqlStatement('SELECT * FROM pwt.spCreateDocumentFromApi(
			' . (int)$this->m_templateId . ',
			\'' . q(DEFAULT_DOCUMENT_NAME) . '\',
			' . (int)DEFAULT_DOCUMENT_PAPER_TYPE . ',
			' . (int)$this->m_journalId . ',
			' . (int)$this->m_submittingAuthorUid . ',
			' . $this->m_uid . '
		)');



		$this->m_documentId = (int)$this->m_con->mRs['id'];
// 		var_dump($this->m_documentId);

		$this->ExecuteSqlStatement('SELECT * FROM spImportDocumentFromExternalXml(
			' . (int)$this->m_documentId . ',
			\'' . q($lXmlDom->saveXML()) . '\',
			' . $this->m_submittingAuthorUid . '
		)');

		$this->m_resultArray['document_id'] = $this->m_documentId;
		$this->m_resultArray['document_link'] = DOCUMENT_VIEW_LINK . $this->m_documentId;

		//Трябва да импортнем фигурите
		$lFiguresQuery = '/document/figures/figure';
		$lFigures = $lXPath->query($lFiguresQuery);
		for($i = 0; $i < $lFigures->length; ++$i){
			$lCurrentFig = $lFigures->item($i);
			$this->ImportSingleFig($lCurrentFig, $lXPath);
		}

		$this->ExecuteSqlStatement('COMMIT TRANSACTION;');
		//echo 1;
		// Трябва да изпълним after save php екшъните
		$this->ExecuteSqlStatement('
			SELECT DISTINCT ON (i.pos, i.id) i.id
			FROM pwt.document_object_instances i
			JOIN pwt.object_actions oa ON oa.object_id = i.object_id
			WHERE i.document_id = ' . (int)$this->m_documentId . '
			AND oa.pos = ' . (int)ACTION_AFTER_SAVE_POS . '
			ORDER BY i.pos DESC
			');
		$lAdditionalParameters = array(
			'try_to_change_user_without_session_change' => 1,
			'username' => $this->m_username,
			'password' => $this->m_password,
		);
		while(!$this->m_con->Eof()){
			$lInstanceId = $this->m_con->mRs['id'];

			performInstanceSaveActions($lInstanceId, $lAdditionalParameters);
			$this->m_con->MoveNext();
		}
		//echo 2;
// 		$this->ExecuteSqlStatement('SELECT * FROM pwt.spUpdateDocumentSubmittingAuthor(' . $this->m_documentId . ')');
	}

	/**
	 *
	 * @param DomNode $pFigNode
	 * @param DOMXPath $pXPath
	 */
	private function ImportSingleFig(&$pFigNode, &$pXPath){
		$lCaption = '';
		$lUrl = '';
		$lCaptionNode = $pXPath->query('./caption', $pFigNode);
		if($lCaptionNode->length){
			$lCaption = $lCaptionNode->item(0)->nodeValue;
		}
		$lIsPlate = false;
		$lPlateId = 0;
		$lPlateType = 0;
		if($pFigNode->getAttribute('is_plate')){
			$lIsPlate = true;
			$lPlateType = $pFigNode->getAttribute('type');
		}

		$lUrlNode = $pXPath->query('./url', $pFigNode);

		for($i = 0; $i < $lUrlNode->length; ++$i){
			$lUrl = $lUrlNode->item($i)->textContent;
			$lFollowingSibling = $pXPath->query('./following-sibling::*[1]', $lUrlNode->item($i));
			$lPhotoDesc = '';
			if($lFollowingSibling->length){
				$lFollowingSiblingNode = $lFollowingSibling->item(0);
				if($lFollowingSiblingNode->nodeName == 'photo_description'){
					$lPhotoDesc = $lFollowingSiblingNode->textContent;
				}
			}

			$lFigSql = 'SELECT * FROM pwt.spuploadfigurephoto(1, null, ' . (int)$this->m_documentId . ', ' . (int)$lPlateId . ', \'' . q($lCaption) . '\', \'' . q($lPhotoDesc	) . '\'
			, ' . (int)$this->m_submittingAuthorUid . ', null, 0, ' . (int)$lPlateType . ')';
			$this->ExecuteSqlStatement($lFigSql);
			$lFigId = (int)$this->m_con->mRs['photo_id'];
			if($lPlateId == 0){
				$lPlateId = (int)$this->m_con->mRs['plate_id'];
			}
			if($lUrl){
				$lPicContent = file_get_contents($lUrl);
				$lPicFileName = PATH_PWT_DL . 'oo_' . $lFigId . '.jpg';
				$lBigPicFileName = PATH_PWT_DL . 'big_' . $lFigId . '.jpg';
				if($lPicContent === false || !file_put_contents($lPicFileName, $lPicContent)){
					$this->SetError(getstr('pwt.api.couldNotDownloadFigPhoto') . ' ' . $lUrl);
				}
				exec("convert -colorspace rgb -quality 80 -thumbnail " . escapeshellarg('1024x1024>') . " " . $lPicFileName . " " . $lBigPicFileName );
			}
		}
	}


	private function ExecuteSqlStatement($pSql, $pSetError = true){
		if(!$this->m_con->Execute($pSql)){
			if($pSetError){
				$this->SetError($this->m_con->GetLastError());
			}
		}

	}

	private function SetError($pErrorMsg){
		$this->m_con->Execute('ROLLBACK;');
		throw new Exception($pErrorMsg);
	}

	private function LogAuthenticate($pLoginIsSuccessful = false, $pErrMsg = ''){
		$lSql = 'SELECT * FROM pwt.spApiLogAuthenticate(\''. $this->m_username . '\', \'' . q($this->m_password) . '\', '
		. (int)$pLoginIsSuccessful . ', \'' . q($pErrMsg) . '\', \'' . q($_SERVER['REMOTE_ADDR']) . '\')';
		$this->ExecuteSqlStatement($lSql, FALSE);
	}

	private function LogDocumentProcessing($pProcessingIsSuccessful = false, $pErrMsg = ''){
		$lSql = 'SELECT * FROM pwt.spApiLogDocumentProcessing('. (int) $this->m_uid . ', \'' . q($this->m_xml) . '\', '
				. (int)$pProcessingIsSuccessful . ', \'' . q($pErrMsg) . '\')';
		$this->ExecuteSqlStatement($lSql, FALSE);
	}

	/**
	 * Тук ще правим базова валидация на xml-a - ще гледаме само
	 * дали структурата на xml-а е ОК. Ще допускаме задължителни полета да са празни.
	 */
	protected function BaseValidateXml(){
		if(!$this->m_xml){
			throw new Exception(getstr('pwt.api.xmlIsRequired'));
		}
		function libxml_display_error($pError) {
			$lResult = "\n";
			switch ($pError->level) {
				case LIBXML_ERR_WARNING :
					$lResult .= "Warning $pError->code: ";
					break;
				case LIBXML_ERR_ERROR :
					$lResult .= "Error $pError->code on line $pError->line: ";
					break;
				case LIBXML_ERR_FATAL :
					$lResult .= "Fatal Error $pError->code: ";
					break;
			}
			$lResult .= trim($pError->message);
			$lResult .= " on line $pError->line";

			return $lResult;
		}

		function libxml_display_errors() {
			$lErrors = libxml_get_errors();
			$lResult = '';
			foreach($lErrors as $lCurrentError){
				$lResult .= libxml_display_error($lCurrentError);
			}
			libxml_clear_errors();
			return $lResult;
		}

		libxml_use_internal_errors(1);
		$lXmlDom = new DOMDocument('1.0', 'UTF-8');

		if(!$lXmlDom->loadXML($this->m_xml)){
			$this->m_resultArray['xml_error'] = libxml_display_errors();
			throw new Exception(getstr('pwt.api.xmlIsInvalid') . $this->m_resultArray['xml_error']);
		}

		$lXPath = new DOMXPath($lXmlDom);
		$lTemplateIdNode = $lXPath->query('/document/document_info/document_type/@id');

		if(!$lTemplateIdNode->length || !(int)$lTemplateIdNode->item(0)->textContent){
			throw new Exception(getstr('pwt.api.noDocumentTypeSpecified'));
		}
		$lTemplateId = (int)$lTemplateIdNode->item(0)->textContent;
		$this->m_templateId = $lTemplateId;

		$lJournalIdNode = $lXPath->query('/document/document_info/journal_name/@id');

		if(!$lJournalIdNode->length || !(int)$lJournalIdNode->item(0)->textContent){
			throw new Exception(getstr('pwt.api.noJoournalIdSpecified'));
		}
		$this->m_journalId = (int)$lJournalIdNode->item(0)->textContent;

		$lTemplateXsdGenerator = new ctemplate_xsd_generator(array(
			'template_id' => $lTemplateId,
		));

		$lTemplateXsdGenerator->GetData();
		$lTemplateXsd = $lTemplateXsdGenerator->getXml();
// 		file_put_contents('./1.xsd', $lTemplateXsd);
// 		var_dump($lTemplateXsd);//

// 		var_dump($lTemplateXsd);
		if(!$lXmlDom->schemaValidateSource($lTemplateXsd)){



			$this->m_resultArray['xml_error'] = libxml_display_errors();
// 			var_dump($this->m_resultArray['xml_error']);
// 			var_dump($this->m_resultArray);
			throw new Exception(getstr('pwt.api.xmlIsInvalid') . $this->m_resultArray['xml_error']);
		}


// 		exit;

	}

	function GetData(){
		if(!$this->m_getData){
			return;
		}
		$this->m_getData = false;
		$lAction = 'authenticate';
		try{
			switch($this->m_action){
				default:
					throw new Exception(getstr('pwt.api.unknownAction'));
				case 'authenticate':{
					$this->Authenticate();
					$this->LogAuthenticate(true);
					break;
				}
				case 'process_document':{
					//~ $this->Authenticate();
					//~ $this->LogAuthenticate(true);
					$lAction = 'process_document';
					$this->ProcessDocumentSubmit();
					//~ $this->LogDocumentProcessing(true);
					break;
				}

			}
		}catch(Exception $pException){
			$this->m_errCnt++;
			//var_dump($pException);
			switch($lAction){
				case 'authenticate':{
					$this->LogAuthenticate(false, $pException->getMessage());
					break;
				}
				case 'process_document':{
					$this->LogDocumentProcessing(false, $pException->getMessage());
					break;
				}

			}
			$this->m_errMsg .= $pException->getMessage();
		}

// 		$_SESSION['suser'] = $this->m_previousSessionUser;
		global $user;
		$user = $this->m_previuosUser;
		//var_dump($this->m_previousSessionUser, $_SESSION['suser']);
	}

	function GetResult(){
		$this->GetData();
		$lResult = new DOMDocument('1.0', 'UTF-8');
		$lRootNode = $lResult->appendChild($lResult->createElement('result'));
		libxml_use_internal_errors(0);
		if($this->m_errCnt){
			$lRootNode->appendChild($lResult->createElement('returnCode', 1));
			$lRootNode->appendChild($lResult->createElement('errorCount', $this->m_errCnt));
			$lRootNode->appendChild($lResult->createElement('errorMsg', $this->m_errMsg));
		}else{
			$lRootNode->appendChild($lResult->createElement('returnCode', 0));
			foreach ($this->m_resultArray as $lKey => $lValue){
				$lRootNode->appendChild($lResult->createElement($lKey, $lValue));
			}
		}
// 		var_dump($lResult->saveXML());
		return $lResult->saveXML();

	}
}